---
title: "TidyCode"
output: html_document
---

```{r, echo=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```

Workbook for data tidying lecture.
We are using data from Hadley's paper found in [github](https://github.com/hadley/tidyr). It's included in the course repository in directory `materials/lectures/Tidy/tidyr/vignettes`.

We're running this Rmarkdown file from directory `materials/lectures/Tidy` so all datasets will be found in this directory afterwards:
```{r}
data_dir <- "tidyr/vignettes"
```

A tidy dataset
----------------

This is a tidy dataset: it has one observation per row, a single variable per column. Notice only information about flights are included here (e.g., no airport information other than the name) in these observations.

```{r}
library(nycflights13)
head(flights)
```

Headers as values
------------------

The first problem we'll see is the case where a table header contains values. At this point we will introduce the `dplyr` package, which we'll use extensively in this course. It is an extremely powerful and efficient way of manipulating tidy data. It will serve as the core of our data manipulation knowledge after this course.

`dplyr` defines a slightly different way of using data.frames. The `tbl_df` function converts a standard R data.frame into a `tbl_df` defined by `dplyr`. One nice thing it does, for example, is print tables in a much friendlier way.

```{r}
library(tidyr)
library(dplyr)

pew <- tbl_df(read.csv(file.path(data_dir, "pew.csv"), stringsAsFactors=FALSE, check.names=FALSE))
pew
```

This table has the number of survey respondents of a specific religion that report their income within some range. A tidy version of this table would consider the *variables* of each observation to be `religion, income, frequency` where `frequency` has the number of respondents for each religion and income range. The function to use in the `tidyr` package is `gather`:

```{r}
tidy_pew <- gather(pew, income, frequency, -religion)
tidy_pew
```

This says: gather all the columns from the `pew` (except `religion`) into key-value columns `income` and `frequency`. This table is much easier to use in other analyses.

Another example: this table has a row for each song appearing in the billboard top 100. It contains track information, and the date it entered the top 100. It then shows the rank in each of the next 76 weeks.

```{r}
billboard <- tbl_df(read.csv(file.path(data_dir, "billboard.csv"), stringsAsFactors=FALSE))
billboard
```

Challenge:
This dataset has values as column names. Which column names are values? How do we tidy this dataset?

Multiple variables in one column
--------------------------------------

The next problem we'll see is the case when we see multiple variables in a single column. Consider the following dataset of tuberculosis cases:

```{r}
tb <- tbl_df(read.csv(file.path(data_dir, "tb.csv"), stringsAsFactors = FALSE))
tb
```

This table has a row for each year and strain of tuberculosis (given by the first two columns). The remaining columns state the number of cases for a given demographic. For example, `m1524` corresponds to males between 15 and 24 years old, and `f1524` are females age 15-24. As you can see each of these columns has two variables: `sex` and `age`.

Challenge: what else is untidy about this dataset?

So, we have to do two operations to tidy this table, first we need to use `gather` the tabulation columns into a `demo` and `n` columns (for demographic and number of cases):

```{r}
tidy_tb <- gather(tb, demo, n, -iso2, -year)
tidy_tb
```

Next, we need to `separate` the values in the `demo` column into two variables `sex` and `age`

```{r}
tidy_tb <- separate(tidy_tb, demo, c("sex", "age"), sep=1)
tidy_tb
```

This calls the `separate` function on table `tidy_db`, separating the `demo` variable into variables `sex` and `age` by separating each value after the first character (that's the `sep` argument).

So, if we put these two commands together we'll see a very common pattern in data manipulation:

```{r}
tidy_tb <- gather(tb, demo, n, -iso2, -year)
tidy_tb <- separate(tidy_tb, demo, c("sex", "age"), sep=1)
tidy_tb
```

We take a table, perform an operation, then take the result and perform another operation on it. This pattern is so common that `dplyr` provides a special syntax to make this more elegant:

```{r}
tidy_tb <- tb %>% 
  gather(demo, n, -iso2, -year)  %>%
  separate(demo, c("sex", "age"), sep=1)
tidy_tb
```

The special syntax `%>%` is called the `pipe` operator (it pipes the result of one operation into the next operation). Specifically, it takes whatever is on the left-hand side, and then puts it into the *first* argument of the function call in the right-hand side.

Challenge: Rewrite the following operations using the pipe operator:

```{r}
tidy_billboard <- gather(billboard, week, rank, wk1:wk76)
tidy_billboard <- separate(tidy_billboard, date.entered, 
                           c("year_entered", "month_entered", "day_entered"),
                           sep="-")
tidy_billboard
```

Variables stored in both rows and columns
-------------------------------------------

This is the messiest, commonly found type of data. Let's take a look at an example, this is daily weather data from for one weather station in Mexico in 2010.

```{r}
weather <- tbl_df(read.csv(file.path(data_dir, "weather.csv"), stringsAsFactors = FALSE))
weather
```

So, we have two rows for each month, one with maximum daily temperature, one with minimum daily temperature, the columns starting with `d` correspond to the day in the where the measurements were made.

Challenge: How would a tidy version of this data look like?

```{r}
weather %>%
  gather(day, value, d1:d31, na.rm=TRUE) %>%
  spread(element, value)
```

The new function we've used here is `spread`. It does the inverse of `gather` it spreads columns `element` and `value` into separate columns.

Multiple types in one table
----------------------------

Remember that an important aspect of tidy data is that it contains exactly one kind of observation in a single table. Let's see the billboard example again after the `gather` operation we did before:

```{r}
tidy_billboard <- billboard %>%
  gather(week, rank, wk1:wk76, na.rm=TRUE)
tidy_billboard
```

Let's sort this table by track to see a problem with this table:

```{r}
tidy_billboard <- tidy_billboard %>%
  arrange(track)
tidy_billboard
```

We have a lot of repeated information in many of these rows (the artist, track name, year, title and date entered). The problem is that this table contains information about both tracks and rank in billboard. That's two different kinds of observations that should belong in two different tables in a tidy dataset.

Let's make a song table that only includes information about songs:

```{r}
song <- tidy_billboard %>%
  select(artist, track, year, time, date.entered) %>%
  unique()
song
```

The `select` function takes a specific set of columns in a table. This is equivalent to the following syntax which we saw last time:

```{r}
tidy_billboard[,c("artist", "track", "year", "time", "date.entered")]
```

The purpose of `dplyr` is to make these type of expressions nicer to write and read. The `unique` function removes any duplicate rows in a table. That's how we have a single row for each song. 

Next, we would like to remove all the song information from the rank table. But we need to do it in a way that still remembers which song each ranking observation corresponds to. To do that, let's first give each song an identifier that we can use to link songs and rankings. So, we can produce the final version of our song table like this:

```{r}
song <- tidy_billboard %>%
  select(artist, track, year, time, date.entered) %>% 
  unique() %>%
  mutate(song_id = row_number())
song
```

The `mutate` function adds a new column to the table, in this case with column name `song_id` and value the row number the song appears in the table (from the `row_number` column).

Now we can make a rank table, we combine the tidy billboard table with our new song table using a `join` (we'll learn all about joins later today). It checks the values on each row of the billboard table and looks for rows in the song table that have the exact same values, and makes a new row that combines the information from both tables. 

```{r}
tidy_billboard %>%
  left_join(song, c("artist", "year", "track", "time", "date.entered"))
```

That adds the `song_id` variable to the `tidy_billboard` table. So now we can remove the song information and only keep ranking information and the `song_id`.

```{r}
rank <- tidy_billboard %>%
  left_join(song, c("artist", "year", "track", "time", "date.entered")) %>%
  select(song_id, week, rank)
rank
```

Challenge:
Let's do a little better job at tidying the billboard dataset:

1. When using `gather` to make the `week` and `rank` columns, remove any weeks where the song does not appear in the top 100. This is coded as missing (`NA`). See the `na.rm` argument to `gather`.  
2. Make `week` a numeric variable (i.e., remove `wk`). See what the `extract_numeric` function does.  
3. Instead of `date.entered` add a `date` column that states the actual date of each ranking. See how R deals with dates `?Date` and how you can turn a string into a `Date` using `as.Date`.  
4. Sort the resulting table by date and rank.
5. Make new `song` and `rank` tables. `song` will now not have the `date.entered` column, and `rank` will have the new `date` column you have just created.


